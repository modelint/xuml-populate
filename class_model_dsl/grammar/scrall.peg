// Scrall grammar â€“ Diagnostic Version (limited capability)
// Do not put trailing comment in last line of grammar. Arpeggio will complain!

activity = statement* EOF
statement = signal_action / sync_invocation / inst_assignment / EOL

// Actions: each must terminate with EOL
signal_action = name supplied_params? SP+ SENDTO (LINEWRAP / SP+) path EOL
sync_invocation = call EOL

// Signal
SENDTO = '->' // Signal action operator

// Synchronous invocation
call = name '.' op
op = name supplied_params?
// Supplied parameter set, can be empty:  ()
supplied_params = '(' (LINEWRAP / SP*) (param SP* (',' (LINEWRAP / SP+) param SP*)*)? LINEWRAP? ')'
param = name (SP* ':' SP* name)?

// Instance assignment
inst_assignment = name SP+ INST_ASSIGN_OP SP+ inst_flow EOL
INST_ASSIGN_OP = '.=' / '..='

// Instance flow
inst_flow = inst_set_source selection?
inst_set_source = call / path / name

selection = '(' (LINEWRAP / SP*) criteria (LINEWRAP / SP*) ')'
criteria = (card SP* ',' SP+ restriction) / CARD / restriction
CARD = '1' / '*'
restriction = attr_comparison ( SP* ',' (LINEWRAP / SP+) attr_comparison)*
attr_comparison = attr_order / comparison
attr_order = ORDER name
comparison = ORDER? 'its.'? name SP* (':' / '==' / COMPARE) SP* scalar_flow
ORDER = '+^' / '-^'
COMPARE = r'[<>][=]?'

scalar_flow = name ('.' ( call / name ))?

path = name? hop+ // path to some instance set represented by a name
hop = '/' (rnum / name) // rnum must be first since name can also match rnum
name = word (NAME_GLUE word)* // One word or a sequence of delimited words (name used for most model elements)

NAME_GLUE = r'[ _]' // delmits words within a name
rnum = r'O?R[1-9][0-9]*' // Relationship number (name used for relationships)
word = r'[A-Za-z][A-Za-z0-9]*'
LINEWRAP = EOL SP* // end of line followed by optional indent on next line
EOL = SP* COMMENT? NL // end of line: Comments, blank lines, whitespace we can omit from the parser result
NL = '\n'
SP = ' '
COMMENT = r'//.*'