higher follow ac .= /OR3/is following/~/its.Altitude |>|
hf ac .= /OR3/is following/~/(( its.Altitude - Altitude ) > y)
cabin .= Cabin(1, ^-.Estimated travel delay( To floor : calling floor, Calling dir: Dir ))
best cabin .= ^-.Estimated travel delay(floor: position)
x = .compute(x, y)
// Tokens
<1>{
    Aircraft(1).Land( Runway: north)
    Cabin at destination() -> /R53/Transfer<X>
    <X>Arrived() -> there
}<2><3>
// Signals
Cabin at destination() -> /R53/Transfer
Cabin at destination() -> /R53/Transfer @ x.compute_delay()
// Decision
!inservice OR x.getClearance(id)? {
    Aircraft(1).Land( Runway: north)
    Cabin at destination() -> /R53/Transfer<X>
    Arrived() -> there
} : {
    Unarrived() -> there
    x = a
}
// Scalar switch with signals
valve position? {
    .open .stuck : close -> my valve
    .closed : open -> my valve
}
// Scalar assignments
speed 2 = myaircraft.groundspeed + area.checkwind() - airspeed
a = b * c / d
ok = a AND b and c and not (d > x)
broken = !shaft.inservice
z = (a != b)
broken = not shaft.inservice
wrong = not -(x * y)
f = A == B == C
m = not working and true
b = Motor.Compute(x: c or d, y: e / f)
my speed = myaircraft.groundspeed + area.checkwind() * airspeed
y = in.hello * in.there
// instance set assignments
q ..= Cabin(*).Closest()/R2/Shaft.Nearest()(id : shaft)
a ..= /R1/R2/Aircraft(alt: high * af; speed <= max speed )
my plane .= Aircraft(Speed: (v or x) or Height > h)
b ..= Cabin(*).Closest()/R2/Shaft.Nearest()(id : shaft)
my plane2 .= Aircraft(Speed: v and Height > h)
my plane3 .= Aircraft(Speed: v and not (Height > h or Length < l))
// call actions
TRAN.Goto floor(floor : Height; direction)
tower.nearest plane().Land( Runway: north)
Aircraft(1).Land( Runway: north)
