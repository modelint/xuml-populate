// Decision
!inservice? {
    Aircraft(1).Land( Runway: north)
    Cabin at destination() -> /R53/Transfer<X>
    Arrived() -> there
} : {
    Unarrived() -> there
    x = a
}
// Scalar switch with signals
valve position? {
    .open .stuck : close -> my valve
    .closed : open -> my valve
}
// Tokens
<1>{
    Aircraft(1).Land( Runway: north)
    Cabin at destination() -> /R53/Transfer<X>
    <X>Arrived() -> there
}<2><3>
// Scalar assignments
speed 2 = myaircraft.groundspeed + area.checkwind() - airspeed
a = b * c / d
ok = a AND b and c and not (d > x)
broken = !shaft.inservice
z = (a != b)
broken = not shaft.inservice
wrong = not -(x * y)
f = A == B == C
my speed = myaircraft.groundspeed + area.checkwind() * airspeed
// instance set assignments
q ..= Cabin(*).Closest()/R2/Shaft.Nearest()(id : shaft)
a ..= /R1/R2/Aircraft(alt: high * af, speed <= max speed )
my plane .= Aircraft(Speed: (v or x) or Height > h)
b ..= Cabin(*).Closest()/R2/Shaft.Nearest()(id : shaft)
my plane2 .= Aircraft(Speed: v and Height > h)
my plane3 .= Aircraft(Speed: v and not (Height > h or Length < l))
// call actions
TRAN.Goto floor(floor : Height, direction)
tower.nearest plane().Land( Runway: north)
Aircraft(1).Land( Runway: north)
