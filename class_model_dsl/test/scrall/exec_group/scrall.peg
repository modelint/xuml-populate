activity = execution_unit* EOF // exec_group test
execution_unit = input_tokens? action_group output_tokens? EOL+
action_group = SP* (block / action) // Set of actions with a common control flow in/out
block = '{' LINEWRAP* execution_unit* '}'
action = (scalar_assignment / delete / scalar_switch / decision / inst_assignment / signal_action / call)?

// Explicit sequence using control flow inputs and outputs
input_tokens = sequence_token+ // Control flow input
output_tokens = sequence_token+ // Control flow output
sequence_token = SP* '<' token_name '>' SP* // Named control flow
token_name = r'[A-Za-z0-9_]+' // No spaces in token names, often single digit: <1>

// Decision action
decision = name true_result false_result? // Control flow version of an if-then
true_result = '?' SP* action_group // If
false_result = SP* ':' SP* action_group // Else

// Switch action
//switch = scalar_switch / subclass_switch
scalar_switch = name '?' SP* case_block // Boolean expr triggers case_block
case_block = '{' LINEWRAP* case+ '}'
case = (SP* enum_value)+ SP* ':' (LINEWRAP* / SP*) execution_unit
enum_value = '.' name // Scalar switch has enum value cases

// Delete action
delete = '!*' SP* instance_set

// Signal action
signal_action = signal delay?
signal = name supplied_params? SP+ '->' (LINEWRAP / SP+) instance_set
delay = SP+ '@' SP+ name

// Instance assignment action
inst_assignment = name SP+ INST_ASSIGN SP+ instance_set
INST_ASSIGN = '.=' / '..='

// Synchronous call action (method or ee operation)
call = instance_set // Post-parse verify that last element is an operation, otherwise invalid call
operation = '.' name supplied_params
supplied_params = '(' SP* (param (',' SP+ param)*)? SP* ')'
param = name (SP* ':' SP* scalar)?

// Instance set
instance_set = (name / path) (selection / operation / path)*
selection = '(' SP* select_phrase SP* ')'
select_phrase = ( (CARD ',' SP* criteria) / CARD / criteria )
attr_comparison = RANK? REFLEX? name comparison? // attr_name
comparison = SP* (MATCH / COMPARE) SP* scalar_expr
CARD = '1' / '*'
RANK = '+^' / '-^'
REFLEX = 'its.'

criteria = SP* logical_or SP*
logical_or = logical_and (SP+ OR SP+ logical_and)*
logical_and = logical_not (( (SP+ AND) / ',') SP+ logical_not)*
logical_not = (NOT SP+)? (attr_comparison / ("(" criteria ")") )

// math and boolean operator precedence
scalar_assignment = name SP* '=' SP* scalar_expr

scalar_expr = SP* scalar_logical_or SP*
scalar_logical_or = scalar_logical_and (SP* OR SP* scalar_logical_and)*
scalar_logical_and = equality (SP* AND SP* equality)*
equality = comparison (SP* EQUAL SP* comparison)*
comparison = addition (SP* COMPARE SP* addition)*
addition = mult (SP* ADD SP* mult)*
mult = exponent (SP* MULT SP* exponent)*
exponent = scalar_logical_not (EXP scalar_logical_not)*
scalar_logical_not = (NOT SP*)? "-"? (scalar / "(" SP* scalar_expr SP* ")")

scalar = name operation / attr_access / name // May yield a scalar value

OR = 'or'
AND = 'and'
NOT = '!' / 'not'
EXP = '^'
EQUAL = '==' / '!='
MATCH = ':'
COMPARE = '>=' / '>' / '<=' / '<'
UNARY = ADD
ADD = ("+" / "-")
MULT = ("*" / "/")

attr_access = name '.' name // Attribute value accessor <class>.<attr>

// Relationship traversal
// We keep path components simple, always beginning with the '/' symbol
path = hop+ // path to some instance set
hop = '/' (rnum / name) // just a sequence of rels and phrase or class names

// Names
name = word (NAME_GLUE word)* // One word or a sequence of delimited words (name used for most model elements)
NAME_GLUE = r'[ _]' // delmits words within a name
rnum = r'O?R[1-9][0-9]*' // Relationship number (name used for relationships)
//word = r'[A-Za-z][A-Za-z0-9]*'
word = ignore_keywords r'[A-Za-z][A-Za-z0-9]*'
ignore_keywords = !" true" !"true " !" false" !"false " !" and" !"and " !" or" !"or " !" not" !"not " !" its" !"its " ! " me" !" me"

// Whitespace and comments
LINEWRAP = EOL SP* // end of line followed by optional indent on next line
EOL = SP* COMMENT? '\n' // end of line: Comments, blank lines, whitespace we can omit from the parser result
COMMENT = '//' r'.*' // Comment slashes don't work if included in the regular expression for some reason
SP = ' '